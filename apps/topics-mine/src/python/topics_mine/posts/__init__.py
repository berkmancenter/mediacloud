import abc
import datetime
import dateutil.parser
import re
from typing import Optional

import requests_mock

from mediawords.util.log import create_logger

from topics_base.posts import get_mock_data

log = create_logger(__name__)


class AbstractPostFetcher(object, metaclass=abc.ABCMeta):

    def __init__(self):
        self.mock_enabled = False

    @abc.abstractmethod
    def fetch_posts_from_api(
        self,
        query: dict,
        start_date: datetime,
        end_date: datetime,
        sample: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> list:
        raise NotImplementedError("Abstract method")

    def validate_mock_post(self, got_post: dict, expected_post: dict) -> None:
        """Validate that got_post matches expected_post.

        This generic version just tests each field in got_post against expected_post, which should be
        whatever got generated by topic_base.posts.get_mock_data().  Override this if that won't work
        for a particular case, for instance with twitter, where there is no channel so we pass the author
        into the channel field.
        """
        for field in ('post_id', 'author', 'channel', 'content'):
            log.debug("%s: %s <-> %s" % (field, got_post[field], expected_post[field]))
            assert got_post[field] == expected_post[field], "field %s does not match" % field

    def test_mock_data(self, query:str='') -> None:
        """Run test of object using mock data.

        This should work on any class, as long as fetch_post() is implemented to return the data from
        get_mock_data when mock_enabled = True.
        """
        self.mock_enabled = True

        expected_posts = get_mock_data()

        start_date = dateutil.parser.parse(expected_posts[0]['publish_date'])
        end_date = dateutil.parser.parse(expected_posts[-1]['publish_date'])

        got_posts = self.fetch_posts(query, start_date, end_date)

        assert len(got_posts) == len(expected_posts)
        for i, got_post in enumerate(got_posts):
            self.validate_mock_post(got_post, expected_posts[i])

    def setup_mock_data(self, mocker: requests_mock.Mocker) -> None:
        """Setup mocker for a given class if self.mock_enabled.

        This is called within a requests_mock.Mocker context, so that requests_mock can be used, but
        you can use it to do whatever mocking setup is needed for the particular class.
        """
        pass

    # noinspection PyMethodMayBeStatic
    def fetch_posts(
        self,
        query: str,
        start_date: datetime,
        end_date: datetime,
        sample: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> list:
        """Fetch reddit posts from pushshift  Setup mocking if self.mock_enabled."""
        if self.mock_enabled:
            with requests_mock.Mocker() as m:
                # add the mocker for the ch api calls
                self.setup_mock_data(m)
                posts = self.fetch_posts_from_api(
                    query=query,
                    start_date=start_date,
                    end_date=end_date,
                    sample=sample,
                    page_size=page_size,
                )

        else:
            posts = self.fetch_posts_from_api(
                query=query,
                start_date=start_date,
                end_date=end_date,
                sample=sample,
                page_size=page_size,
            )

        for post in posts:
            post['urls'] = self.get_post_urls(post)

        return posts

    def get_post_urls(self, post: dict) -> list:
        """Given a post, return a list of urls included in the post."""
        links = []
        for url in re.findall(r'https?://[^\s\")]+', post['content']):
            url = re.sub(r'\W+$', '', url)
            links.append(url)

        return links


